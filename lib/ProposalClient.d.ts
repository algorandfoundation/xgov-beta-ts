/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { AlgorandClientInterface } from '@algorandfoundation/algokit-utils/types/algorand-client-interface';
import { ABIReturn } from '@algorandfoundation/algokit-utils/types/app';
import { Arc56Contract } from '@algorandfoundation/algokit-utils/types/app-arc56';
import { AppClient as _AppClient, AppClientMethodCallParams, AppClientParams, AppClientBareCallParams, CallOnComplete, AppClientCompilationParams, ResolveAppClientByCreatorAndName, ResolveAppClientByNetwork, CloneAppClientParams } from '@algorandfoundation/algokit-utils/types/app-client';
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory';
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer';
import { SendParams, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction';
import { modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk';
import SimulateResponse = modelsv2.SimulateResponse;
export declare const APP_SPEC: Arc56Contract;
/**
 * A state record containing binary data
 */
export interface BinaryState {
    /**
     * Gets the state value as a Uint8Array
     */
    asByteArray(): Uint8Array | undefined;
    /**
     * Gets the state value as a string
     */
    asString(): string | undefined;
}
/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R ? (...args: Expand<A>) => Expand<R> : T extends infer O ? {
    [K in keyof O]: O[K];
} : never;
export type ProposalTypedGlobalState = {
    proposer: string;
    registryAppId: bigint;
    title: string;
    submissionTs: bigint;
    finalizationTs: bigint;
    voteOpenTs: bigint;
    status: bigint;
    decommissioned: boolean;
    fundingCategory: bigint;
    focus: number;
    fundingType: bigint;
    requestedAmount: bigint;
    lockedAmount: bigint;
    committeeId: Uint8Array;
    committeeMembers: bigint;
    committeeVotes: bigint;
    votedMembers: bigint;
    approvals: bigint;
    rejections: bigint;
    nulls: bigint;
};
/**
 * Converts the ABI tuple representation of a ProposalTypedGlobalState to the struct representation
 */
export declare function ProposalTypedGlobalStateFromTuple(abiTuple: [string, bigint, string, bigint, bigint, bigint, bigint, boolean, bigint, number, bigint, bigint, bigint, Uint8Array, bigint, bigint, bigint, bigint, bigint, bigint]): ProposalTypedGlobalState;
/**
 * The argument types for the Proposal contract
 */
export type ProposalArgs = {
    /**
     * The object representation of the arguments for each method
     */
    obj: {
        'create(address)void': {
            /**
             * Address of the proposer
             */
            proposer: string;
        };
        'submit(pay,string,uint64,uint64,uint8)void': {
            /**
             * Commitment payment transaction from the proposer to the contract
             */
            payment: AppMethodCallTransactionArgument;
            /**
             * Proposal title, max TITLE_MAX_BYTES bytes
             */
            title: string;
            /**
             * Funding type (Proactive / Retroactive)
             */
            fundingType: bigint | number;
            /**
             * Requested amount in microAlgos
             */
            requestedAmount: bigint | number;
            /**
             * Proposal focus area
             */
            focus: bigint | number;
        };
        'upload_metadata(byte[],bool)void': {
            /**
             * Metadata payload
             */
            payload: Uint8Array;
            /**
             * True if this is the first upload call in a group transaction
             */
            isFirstInGroup: boolean;
        };
        'drop()string': Record<string, never>;
        'finalize()void': Record<string, never>;
        'assign_voters((address,uint64)[])void': {
            /**
             * List of voter addresses with their voting power
             */
            voters: [string, bigint | number][];
        };
        'vote(address,uint64,uint64)string': {
            /**
             * Voter address
             */
            voter: string;
            /**
             * Number of approvals
             */
            approvals: bigint | number;
            /**
             * Number of rejections
             */
            rejections: bigint | number;
        };
        'scrutiny()void': Record<string, never>;
        'review(bool)void': {
            /**
             * Whether to block the proposal or not
             */
            block: boolean;
        };
        'fund()string': Record<string, never>;
        'unassign_voters(address[])void': {
            /**
             * List of voters to be unassigned
             */
            voters: string[];
        };
        'decommission()string': Record<string, never>;
        'delete()void': Record<string, never>;
        'get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)': Record<string, never>;
        'op_up()void': Record<string, never>;
    };
    /**
     * The tuple representation of the arguments for each method
     */
    tuple: {
        'create(address)void': [proposer: string];
        'submit(pay,string,uint64,uint64,uint8)void': [payment: AppMethodCallTransactionArgument, title: string, fundingType: bigint | number, requestedAmount: bigint | number, focus: bigint | number];
        'upload_metadata(byte[],bool)void': [payload: Uint8Array, isFirstInGroup: boolean];
        'drop()string': [];
        'finalize()void': [];
        'assign_voters((address,uint64)[])void': [voters: [string, bigint | number][]];
        'vote(address,uint64,uint64)string': [voter: string, approvals: bigint | number, rejections: bigint | number];
        'scrutiny()void': [];
        'review(bool)void': [block: boolean];
        'fund()string': [];
        'unassign_voters(address[])void': [voters: string[]];
        'decommission()string': [];
        'delete()void': [];
        'get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)': [];
        'op_up()void': [];
    };
};
/**
 * The return type for each method
 */
export type ProposalReturns = {
    'create(address)void': void;
    'submit(pay,string,uint64,uint64,uint8)void': void;
    'upload_metadata(byte[],bool)void': void;
    'drop()string': string;
    'finalize()void': void;
    'assign_voters((address,uint64)[])void': void;
    'vote(address,uint64,uint64)string': string;
    'scrutiny()void': void;
    'review(bool)void': void;
    'fund()string': string;
    'unassign_voters(address[])void': void;
    'decommission()string': string;
    'delete()void': void;
    'get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)': ProposalTypedGlobalState;
    'op_up()void': void;
};
/**
 * Defines the types of available calls and state of the Proposal smart contract.
 */
export type ProposalTypes = {
    /**
     * Maps method signatures / names to their argument and return types.
     */
    methods: Record<'create(address)void' | 'create', {
        argsObj: ProposalArgs['obj']['create(address)void'];
        argsTuple: ProposalArgs['tuple']['create(address)void'];
        returns: ProposalReturns['create(address)void'];
    }> & Record<'submit(pay,string,uint64,uint64,uint8)void' | 'submit', {
        argsObj: ProposalArgs['obj']['submit(pay,string,uint64,uint64,uint8)void'];
        argsTuple: ProposalArgs['tuple']['submit(pay,string,uint64,uint64,uint8)void'];
        returns: ProposalReturns['submit(pay,string,uint64,uint64,uint8)void'];
    }> & Record<'upload_metadata(byte[],bool)void' | 'upload_metadata', {
        argsObj: ProposalArgs['obj']['upload_metadata(byte[],bool)void'];
        argsTuple: ProposalArgs['tuple']['upload_metadata(byte[],bool)void'];
        returns: ProposalReturns['upload_metadata(byte[],bool)void'];
    }> & Record<'drop()string' | 'drop', {
        argsObj: ProposalArgs['obj']['drop()string'];
        argsTuple: ProposalArgs['tuple']['drop()string'];
        returns: ProposalReturns['drop()string'];
    }> & Record<'finalize()void' | 'finalize', {
        argsObj: ProposalArgs['obj']['finalize()void'];
        argsTuple: ProposalArgs['tuple']['finalize()void'];
        returns: ProposalReturns['finalize()void'];
    }> & Record<'assign_voters((address,uint64)[])void' | 'assign_voters', {
        argsObj: ProposalArgs['obj']['assign_voters((address,uint64)[])void'];
        argsTuple: ProposalArgs['tuple']['assign_voters((address,uint64)[])void'];
        returns: ProposalReturns['assign_voters((address,uint64)[])void'];
    }> & Record<'vote(address,uint64,uint64)string' | 'vote', {
        argsObj: ProposalArgs['obj']['vote(address,uint64,uint64)string'];
        argsTuple: ProposalArgs['tuple']['vote(address,uint64,uint64)string'];
        returns: ProposalReturns['vote(address,uint64,uint64)string'];
    }> & Record<'scrutiny()void' | 'scrutiny', {
        argsObj: ProposalArgs['obj']['scrutiny()void'];
        argsTuple: ProposalArgs['tuple']['scrutiny()void'];
        returns: ProposalReturns['scrutiny()void'];
    }> & Record<'review(bool)void' | 'review', {
        argsObj: ProposalArgs['obj']['review(bool)void'];
        argsTuple: ProposalArgs['tuple']['review(bool)void'];
        returns: ProposalReturns['review(bool)void'];
    }> & Record<'fund()string' | 'fund', {
        argsObj: ProposalArgs['obj']['fund()string'];
        argsTuple: ProposalArgs['tuple']['fund()string'];
        returns: ProposalReturns['fund()string'];
    }> & Record<'unassign_voters(address[])void' | 'unassign_voters', {
        argsObj: ProposalArgs['obj']['unassign_voters(address[])void'];
        argsTuple: ProposalArgs['tuple']['unassign_voters(address[])void'];
        returns: ProposalReturns['unassign_voters(address[])void'];
    }> & Record<'decommission()string' | 'decommission', {
        argsObj: ProposalArgs['obj']['decommission()string'];
        argsTuple: ProposalArgs['tuple']['decommission()string'];
        returns: ProposalReturns['decommission()string'];
    }> & Record<'delete()void' | 'delete', {
        argsObj: ProposalArgs['obj']['delete()void'];
        argsTuple: ProposalArgs['tuple']['delete()void'];
        returns: ProposalReturns['delete()void'];
    }> & Record<'get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)' | 'get_state', {
        argsObj: ProposalArgs['obj']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'];
        argsTuple: ProposalArgs['tuple']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'];
        /**
         * The proposal state
         */
        returns: ProposalReturns['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'];
    }> & Record<'op_up()void' | 'op_up', {
        argsObj: ProposalArgs['obj']['op_up()void'];
        argsTuple: ProposalArgs['tuple']['op_up()void'];
        returns: ProposalReturns['op_up()void'];
    }>;
    /**
     * Defines the shape of the state of the application.
     */
    state: {
        global: {
            keys: {
                approvals: bigint;
                assignedVotes: bigint;
                committeeId: BinaryState;
                committeeMembers: bigint;
                committeeVotes: bigint;
                decommissioned: bigint;
                finalizationTs: bigint;
                focus: bigint;
                fundingCategory: bigint;
                fundingType: bigint;
                lockedAmount: bigint;
                nulls: bigint;
                proposer: BinaryState;
                registryAppId: bigint;
                rejections: bigint;
                requestedAmount: bigint;
                status: bigint;
                submissionTs: bigint;
                title: BinaryState;
                voteOpenTs: bigint;
                votedMembers: bigint;
                votersCount: bigint;
            };
            maps: {};
        };
    };
};
/**
 * Defines the possible abi call signatures.
 */
export type ProposalSignatures = keyof ProposalTypes['methods'];
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type ProposalNonVoidMethodSignatures = keyof ProposalTypes['methods'] extends infer T ? T extends keyof ProposalTypes['methods'] ? MethodReturn<T> extends void ? never : T : never : never;
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> & {
    /** The args for the ABI method call, either as an ordered array or an object */
    args: Expand<TArgs>;
}>;
/**
 * Maps a method signature from the Proposal smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends ProposalSignatures> = ProposalTypes['methods'][TSignature]['argsObj' | 'argsTuple'];
/**
 * Maps a method signature from the Proposal smart contract to the method's return type
 */
export type MethodReturn<TSignature extends ProposalSignatures> = ProposalTypes['methods'][TSignature]['returns'];
/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = ProposalTypes['state']['global']['keys'];
/**
 * Defines supported create method params for this smart contract
 */
export type ProposalCreateCallParams = Expand<CallParams<ProposalArgs['obj']['create(address)void'] | ProposalArgs['tuple']['create(address)void']> & {
    method: 'create';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema> | Expand<CallParams<ProposalArgs['obj']['create(address)void'] | ProposalArgs['tuple']['create(address)void']> & {
    method: 'create(address)void';
} & {
    onComplete?: OnApplicationComplete.NoOpOC;
} & CreateSchema>;
/**
 * Defines supported delete method params for this smart contract
 */
export type ProposalDeleteCallParams = Expand<CallParams<ProposalArgs['obj']['delete()void'] | ProposalArgs['tuple']['delete()void']> & {
    method: 'delete';
}> | Expand<CallParams<ProposalArgs['obj']['delete()void'] | ProposalArgs['tuple']['delete()void']> & {
    method: 'delete()void';
}>;
/**
 * Defines arguments required for the deploy method.
 */
export type ProposalDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
    /**
     * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    createParams?: ProposalCreateCallParams;
    /**
     * Delete transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
     */
    deleteParams?: ProposalDeleteCallParams;
}>;
/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the Proposal smart contract
 */
export declare abstract class ProposalParamsFactory {
    /**
     * Gets available create ABI call param factories
     */
    static get create(): {
        _resolveByMethod<TParams extends ProposalCreateCallParams & {
            method: string;
        }>(params: TParams): {
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: string | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: string[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: string | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        } & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
        /**
         * Constructs create ABI call params for the Proposal smart contract using the create(address)void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        create(params: CallParams<ProposalArgs["obj"]["create(address)void"] | ProposalArgs["tuple"]["create(address)void"]> & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }): AppClientMethodCallParams & AppClientCompilationParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        };
    };
    /**
     * Gets available delete ABI call param factories
     */
    static get delete(): {
        _resolveByMethod<TParams extends ProposalDeleteCallParams & {
            method: string;
        }>(params: TParams): {
            signer?: (TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount) | undefined;
            rekeyTo?: string | undefined;
            note?: (Uint8Array | string) | undefined;
            lease?: (Uint8Array | string) | undefined;
            staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
            validityWindow?: number | undefined;
            firstValidRound?: bigint | undefined;
            lastValidRound?: bigint | undefined;
            onComplete?: OnApplicationComplete | undefined;
            accountReferences?: string[] | undefined;
            appReferences?: bigint[] | undefined;
            assetReferences?: bigint[] | undefined;
            boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference | import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier)[] | undefined;
            sender?: string | undefined;
            method: string;
            args?: (import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | AppMethodCallTransactionArgument | undefined)[] | undefined;
        };
        /**
         * Constructs delete ABI call params for the Proposal smart contract using the delete()void ABI method
         *
         * @param params Parameters for the call
         * @returns An `AppClientMethodCallParams` object for the call
         */
        delete(params: CallParams<ProposalArgs["obj"]["delete()void"] | ProposalArgs["tuple"]["delete()void"]>): AppClientMethodCallParams;
    };
    /**
     * Constructs a no op call for the submit(pay,string,uint64,uint64,uint8)void ABI method
     *
     * Submit the first draft of the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static submit(params: CallParams<ProposalArgs['obj']['submit(pay,string,uint64,uint64,uint8)void'] | ProposalArgs['tuple']['submit(pay,string,uint64,uint64,uint8)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the upload_metadata(byte[],bool)void ABI method
     *
     * Upload the proposal metadata.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static uploadMetadata(params: CallParams<ProposalArgs['obj']['upload_metadata(byte[],bool)void'] | ProposalArgs['tuple']['upload_metadata(byte[],bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the drop()string ABI method
     *
     * Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static drop(params: CallParams<ProposalArgs['obj']['drop()string'] | ProposalArgs['tuple']['drop()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the finalize()void ABI method
     *
     * Finalize the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static finalize(params: CallParams<ProposalArgs['obj']['finalize()void'] | ProposalArgs['tuple']['finalize()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the assign_voters((address,uint64)[])void ABI method
     *
     * Assign multiple voters to the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static assignVoters(params: CallParams<ProposalArgs['obj']['assign_voters((address,uint64)[])void'] | ProposalArgs['tuple']['assign_voters((address,uint64)[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the vote(address,uint64,uint64)string ABI method
     *
     * Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static vote(params: CallParams<ProposalArgs['obj']['vote(address,uint64,uint64)string'] | ProposalArgs['tuple']['vote(address,uint64,uint64)string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the scrutiny()void ABI method
     *
     * Scrutinize the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static scrutiny(params: CallParams<ProposalArgs['obj']['scrutiny()void'] | ProposalArgs['tuple']['scrutiny()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the review(bool)void ABI method
     *
     * Review the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static review(params: CallParams<ProposalArgs['obj']['review(bool)void'] | ProposalArgs['tuple']['review(bool)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the fund()string ABI method
     *
     * Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static fund(params: CallParams<ProposalArgs['obj']['fund()string'] | ProposalArgs['tuple']['fund()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the unassign_voters(address[])void ABI method
     *
     * Unassign voters from the proposal.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static unassignVoters(params: CallParams<ProposalArgs['obj']['unassign_voters(address[])void'] | ProposalArgs['tuple']['unassign_voters(address[])void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the decommission()string ABI method
     *
     * Decommission the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static decommission(params: CallParams<ProposalArgs['obj']['decommission()string'] | ProposalArgs['tuple']['decommission()string']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64) ABI method
     *
     * Get the proposal state.
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static getState(params: CallParams<ProposalArgs['obj']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'] | ProposalArgs['tuple']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
    /**
     * Constructs a no op call for the op_up()void ABI method
     *
     * @param params Parameters for the call
     * @returns An `AppClientMethodCallParams` object for the call
     */
    static opUp(params: CallParams<ProposalArgs['obj']['op_up()void'] | ProposalArgs['tuple']['op_up()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete;
}
/**
 * A factory to create and deploy one or more instance of the Proposal smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export declare class ProposalFactory {
    /**
     * The underlying `AppFactory` for when you want to have more flexibility
     */
    readonly appFactory: _AppFactory;
    /**
     * Creates a new instance of `ProposalFactory`
     *
     * @param params The parameters to initialise the app factory with
     */
    constructor(params: Omit<AppFactoryParams, 'appSpec'>);
    /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app factory is using. */
    get algorand(): AlgorandClientInterface;
    /**
     * Returns a new `AppClient` client for an app instance of the given ID.
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientById(params: AppFactoryAppClientParams): ProposalClient;
    /**
     * Returns a new `AppClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     *
     * Automatically populates appName, defaultSender and source maps from the factory
     * if not specified in the params.
     * @param params The parameters to create the app client
     * @returns The `AppClient`
     */
    getAppClientByCreatorAndName(params: AppFactoryResolveAppClientByCreatorAndNameParams): Promise<ProposalClient>;
    /**
     * Idempotently deploys the Proposal smart contract.
     *
     * @param params The arguments for the contract calls and any additional parameters for the call
     * @returns The deployment result
     */
    deploy(params?: ProposalDeployParams): Promise<{
        result: {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "create";
            version: string;
            name: string;
            deleted: boolean;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: string;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "update";
            appId: bigint;
            appAddress: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "replace";
            version: string;
            name: string;
            deleted: boolean;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
            groupId: string;
            txIds: string[];
            returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            appId: bigint;
            appAddress: string;
            deleteResult: import("@algorandfoundation/algokit-utils/types/transaction").ConfirmedTransactionResult;
        } | {
            return: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            deleteReturn: import("algosdk").ABIValue | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined;
            compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
            operationPerformed: "nothing";
            appId: bigint;
            appAddress: string;
            createdRound: bigint;
            updatedRound: bigint;
            createdMetadata: import("@algorandfoundation/algokit-utils/types/app").AppDeployMetadata;
            deleted: boolean;
            name: string;
            version: string;
            deletable?: boolean | undefined;
            updatable?: boolean | undefined;
        };
        appClient: ProposalClient;
    }>;
    /**
     * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Proposal smart contract using the create(address)void ABI method.
             *
             * Create a new proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
             *
             * @param params The params for the smart contract call
             * @returns The create params
             */
            create: (params: CallParams<ProposalArgs["obj"]["create(address)void"] | ProposalArgs["tuple"]["create(address)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                deployTimeParams: import("@algorandfoundation/algokit-utils/types/app").TealTemplateParams | undefined;
                schema: {
                    globalInts: number;
                    globalByteSlices: number;
                    localInts: number;
                    localByteSlices: number;
                };
                approvalProgram: Uint8Array;
                clearStateProgram: Uint8Array;
                lease?: string | Uint8Array | undefined;
                note?: string | Uint8Array | undefined;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                rekeyTo?: string | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                accountReferences?: string[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
                updatable?: boolean | undefined;
                deletable?: boolean | undefined;
                extraProgramPages?: number | undefined;
            } & {
                sender: string;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    lease?: string | Uint8Array | undefined;
                    note?: string | Uint8Array | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    sender: string;
                    rekeyTo?: string | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    accountReferences?: string[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: string[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC;
            }>;
        };
        /**
         * Gets available deployDelete methods
         */
        deployDelete: {
            /**
             * Deletes an existing instance of the Proposal smart contract using the delete()void ABI method.
             *
             * Delete the proposal.
             *
             * @param params The params for the smart contract call
             * @returns The deployDelete params
             */
            delete: (params?: CallParams<ProposalArgs["obj"]["delete()void"] | ProposalArgs["tuple"]["delete()void"]>) => {
                lease?: string | Uint8Array | undefined;
                note?: string | Uint8Array | undefined;
                maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                rekeyTo?: string | undefined;
                staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                validityWindow?: number | undefined;
                firstValidRound?: bigint | undefined;
                lastValidRound?: bigint | undefined;
                onComplete?: OnApplicationComplete | undefined;
                accountReferences?: string[] | undefined;
                appReferences?: bigint[] | undefined;
                assetReferences?: bigint[] | undefined;
                boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                sender?: string | undefined;
                method: string;
                args?: (import("algosdk").ABIValue | AppMethodCallTransactionArgument | import("@algorandfoundation/algokit-utils/types/app-arc56").ABIStruct | undefined)[] | undefined;
            } & {
                sender: string;
                signer: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                method: import("@algorandfoundation/algokit-utils/types/app-arc56").Arc56Method;
                args: (Transaction | import("algosdk").ABIValue | import("algosdk").TransactionWithSigner | Promise<Transaction> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    lease?: string | Uint8Array | undefined;
                    note?: string | Uint8Array | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    args?: Uint8Array[] | undefined;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    sender: string;
                    rekeyTo?: string | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    onComplete?: OnApplicationComplete.NoOpOC | OnApplicationComplete.OptInOC | OnApplicationComplete.CloseOutOC | OnApplicationComplete.UpdateApplicationOC | OnApplicationComplete.DeleteApplicationOC | undefined;
                    accountReferences?: string[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                    schema?: {
                        globalInts: number;
                        globalByteSlices: number;
                        localInts: number;
                        localByteSlices: number;
                    } | undefined;
                    extraProgramPages?: number | undefined;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<{
                    sender: string;
                    signer?: TransactionSigner | import("@algorandfoundation/algokit-utils/types/account").TransactionSignerAccount | undefined;
                    rekeyTo?: string | undefined;
                    note?: string | Uint8Array | undefined;
                    lease?: string | Uint8Array | undefined;
                    staticFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    extraFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    maxFee?: import("@algorandfoundation/algokit-utils/types/amount").AlgoAmount | undefined;
                    validityWindow?: number | undefined;
                    firstValidRound?: bigint | undefined;
                    lastValidRound?: bigint | undefined;
                    appId: bigint;
                    onComplete?: OnApplicationComplete.UpdateApplicationOC | undefined;
                    args?: Uint8Array[] | undefined;
                    accountReferences?: string[] | undefined;
                    appReferences?: bigint[] | undefined;
                    assetReferences?: bigint[] | undefined;
                    boxReferences?: (import("@algorandfoundation/algokit-utils/types/app-manager").BoxIdentifier | import("@algorandfoundation/algokit-utils/types/app-manager").BoxReference)[] | undefined;
                    approvalProgram: string | Uint8Array;
                    clearStateProgram: string | Uint8Array;
                }> | import("@algorandfoundation/algokit-utils/types/composer").AppMethodCall<import("@algorandfoundation/algokit-utils/types/composer").AppMethodCallParams> | undefined)[] | undefined;
                onComplete: OnApplicationComplete.DeleteApplicationOC;
            };
        };
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Proposal smart contract using the create(address)void ABI method.
             *
             * Create a new proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
             *
             * @param params The params for the smart contract call
             * @returns The create transaction
             */
            create: (params: CallParams<ProposalArgs["obj"]["create(address)void"] | ProposalArgs["tuple"]["create(address)void"]> & AppClientCompilationParams & CreateSchema & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available create methods
         */
        create: {
            /**
             * Creates a new instance of the Proposal smart contract using an ABI method call using the create(address)void ABI method.
             *
             * Create a new proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
             *
             * @param params The params for the smart contract call
             * @returns The create result
             */
            create: (params: CallParams<ProposalArgs["obj"]["create(address)void"] | ProposalArgs["tuple"]["create(address)void"]> & AppClientCompilationParams & CreateSchema & SendParams & {
                onComplete?: OnApplicationComplete.NoOpOC;
            }) => Promise<{
                result: {
                    return: (undefined | ProposalReturns["create(address)void"]);
                    compiledApproval?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    compiledClear?: import("@algorandfoundation/algokit-utils/types/app").CompiledTeal | undefined;
                    appId: bigint;
                    groupId: string;
                    txIds: string[];
                    returns?: import("@algorandfoundation/algokit-utils/types/app").ABIReturn[] | undefined;
                    confirmations: modelsv2.PendingTransactionResponse[];
                    transactions: Transaction[];
                    confirmation: modelsv2.PendingTransactionResponse;
                    transaction: Transaction;
                    appAddress: string;
                };
                appClient: ProposalClient;
            }>;
        };
    };
}
/**
 * A client to make calls to the Proposal smart contract
 */
export declare class ProposalClient {
    /**
     * The underlying `AppClient` for when you want to have more flexibility
     */
    readonly appClient: _AppClient;
    /**
     * Creates a new instance of `ProposalClient`
     *
     * @param appClient An `AppClient` instance which has been created with the Proposal app spec
     */
    constructor(appClient: _AppClient);
    /**
     * Creates a new instance of `ProposalClient`
     *
     * @param params The parameters to initialise the app client with
     */
    constructor(params: Omit<AppClientParams, 'appSpec'>);
    /**
     * Checks for decode errors on the given return value and maps the return value to the return type for the given method
     * @returns The typed return value or undefined if there was no value
     */
    decodeReturnValue<TSignature extends ProposalNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined): MethodReturn<TSignature> | undefined;
    /**
     * Returns a new `ProposalClient` client, resolving the app by creator address and name
     * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
     * @param params The parameters to create the app client
     */
    static fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<ProposalClient>;
    /**
     * Returns an `ProposalClient` instance for the current network based on
     * pre-determined network-specific app IDs specified in the ARC-56 app spec.
     *
     * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
     * @param params The parameters to create the app client
     */
    static fromNetwork(params: Omit<ResolveAppClientByNetwork, 'appSpec'>): Promise<ProposalClient>;
    /** The ID of the app instance this client is linked to. */
    get appId(): bigint;
    /** The app address of the app instance this client is linked to. */
    get appAddress(): string;
    /** The name of the app. */
    get appName(): string;
    /** The ARC-56 app spec being used */
    get appSpec(): Arc56Contract;
    /** A reference to the underlying `AlgorandClient` this app client is using. */
    get algorand(): AlgorandClientInterface;
    /**
     * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
     */
    readonly params: {
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the Proposal smart contract using the `delete()void` ABI method.
             *
             * Delete the proposal.
             *
             * @param params The params for the smart contract call
             * @returns The delete params
             */
            delete: (params?: CallParams<ProposalArgs["obj"]["delete()void"] | ProposalArgs["tuple"]["delete()void"]>) => Promise<import("@algorandfoundation/algokit-utils/types/composer").AppDeleteMethodCall>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Proposal smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => import("@algorandfoundation/algokit-utils/types/composer").AppCallParams;
        /**
         * Makes a call to the Proposal smart contract using the `submit(pay,string,uint64,uint64,uint8)void` ABI method.
         *
         * Submit the first draft of the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        submit: (params: CallParams<ProposalArgs["obj"]["submit(pay,string,uint64,uint64,uint8)void"] | ProposalArgs["tuple"]["submit(pay,string,uint64,uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `upload_metadata(byte[],bool)void` ABI method.
         *
         * Upload the proposal metadata.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        uploadMetadata: (params: CallParams<ProposalArgs["obj"]["upload_metadata(byte[],bool)void"] | ProposalArgs["tuple"]["upload_metadata(byte[],bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `drop()string` ABI method.
         *
         * Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        drop: (params?: CallParams<ProposalArgs["obj"]["drop()string"] | ProposalArgs["tuple"]["drop()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `finalize()void` ABI method.
         *
         * Finalize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        finalize: (params?: CallParams<ProposalArgs["obj"]["finalize()void"] | ProposalArgs["tuple"]["finalize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `assign_voters((address,uint64)[])void` ABI method.
         *
         * Assign multiple voters to the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        assignVoters: (params: CallParams<ProposalArgs["obj"]["assign_voters((address,uint64)[])void"] | ProposalArgs["tuple"]["assign_voters((address,uint64)[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `vote(address,uint64,uint64)string` ABI method.
         *
         * Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        vote: (params: CallParams<ProposalArgs["obj"]["vote(address,uint64,uint64)string"] | ProposalArgs["tuple"]["vote(address,uint64,uint64)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `scrutiny()void` ABI method.
         *
         * Scrutinize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        scrutiny: (params?: CallParams<ProposalArgs["obj"]["scrutiny()void"] | ProposalArgs["tuple"]["scrutiny()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `review(bool)void` ABI method.
         *
         * Review the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        review: (params: CallParams<ProposalArgs["obj"]["review(bool)void"] | ProposalArgs["tuple"]["review(bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `fund()string` ABI method.
         *
         * Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        fund: (params?: CallParams<ProposalArgs["obj"]["fund()string"] | ProposalArgs["tuple"]["fund()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `unassign_voters(address[])void` ABI method.
         *
         * Unassign voters from the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        unassignVoters: (params: CallParams<ProposalArgs["obj"]["unassign_voters(address[])void"] | ProposalArgs["tuple"]["unassign_voters(address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `decommission()string` ABI method.
         *
         * Decommission the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        decommission: (params?: CallParams<ProposalArgs["obj"]["decommission()string"] | ProposalArgs["tuple"]["decommission()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Get the proposal state.
         *
         * @param params The params for the smart contract call
         * @returns The call params: The proposal state
         */
        getState: (params?: CallParams<ProposalArgs["obj"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"] | ProposalArgs["tuple"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
        /**
         * Makes a call to the Proposal smart contract using the `op_up()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call params
         */
        opUp: (params?: CallParams<ProposalArgs["obj"]["op_up()void"] | ProposalArgs["tuple"]["op_up()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<AppCallMethodCall>;
    };
    /**
     * Create transactions for the current app
     */
    readonly createTransaction: {
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the Proposal smart contract using the `delete()void` ABI method.
             *
             * Delete the proposal.
             *
             * @param params The params for the smart contract call
             * @returns The delete transaction
             */
            delete: (params?: CallParams<ProposalArgs["obj"]["delete()void"] | ProposalArgs["tuple"]["delete()void"]>) => Promise<{
                transactions: Transaction[];
                methodCalls: Map<number, import("algosdk").ABIMethod>;
                signers: Map<number, TransactionSigner>;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Proposal smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams>) => Promise<Transaction>;
        /**
         * Makes a call to the Proposal smart contract using the `submit(pay,string,uint64,uint64,uint8)void` ABI method.
         *
         * Submit the first draft of the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        submit: (params: CallParams<ProposalArgs["obj"]["submit(pay,string,uint64,uint64,uint8)void"] | ProposalArgs["tuple"]["submit(pay,string,uint64,uint64,uint8)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `upload_metadata(byte[],bool)void` ABI method.
         *
         * Upload the proposal metadata.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        uploadMetadata: (params: CallParams<ProposalArgs["obj"]["upload_metadata(byte[],bool)void"] | ProposalArgs["tuple"]["upload_metadata(byte[],bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `drop()string` ABI method.
         *
         * Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        drop: (params?: CallParams<ProposalArgs["obj"]["drop()string"] | ProposalArgs["tuple"]["drop()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `finalize()void` ABI method.
         *
         * Finalize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        finalize: (params?: CallParams<ProposalArgs["obj"]["finalize()void"] | ProposalArgs["tuple"]["finalize()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `assign_voters((address,uint64)[])void` ABI method.
         *
         * Assign multiple voters to the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        assignVoters: (params: CallParams<ProposalArgs["obj"]["assign_voters((address,uint64)[])void"] | ProposalArgs["tuple"]["assign_voters((address,uint64)[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `vote(address,uint64,uint64)string` ABI method.
         *
         * Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        vote: (params: CallParams<ProposalArgs["obj"]["vote(address,uint64,uint64)string"] | ProposalArgs["tuple"]["vote(address,uint64,uint64)string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `scrutiny()void` ABI method.
         *
         * Scrutinize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        scrutiny: (params?: CallParams<ProposalArgs["obj"]["scrutiny()void"] | ProposalArgs["tuple"]["scrutiny()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `review(bool)void` ABI method.
         *
         * Review the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        review: (params: CallParams<ProposalArgs["obj"]["review(bool)void"] | ProposalArgs["tuple"]["review(bool)void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `fund()string` ABI method.
         *
         * Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        fund: (params?: CallParams<ProposalArgs["obj"]["fund()string"] | ProposalArgs["tuple"]["fund()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `unassign_voters(address[])void` ABI method.
         *
         * Unassign voters from the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        unassignVoters: (params: CallParams<ProposalArgs["obj"]["unassign_voters(address[])void"] | ProposalArgs["tuple"]["unassign_voters(address[])void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `decommission()string` ABI method.
         *
         * Decommission the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        decommission: (params?: CallParams<ProposalArgs["obj"]["decommission()string"] | ProposalArgs["tuple"]["decommission()string"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Get the proposal state.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction: The proposal state
         */
        getState: (params?: CallParams<ProposalArgs["obj"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"] | ProposalArgs["tuple"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `op_up()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call transaction
         */
        opUp: (params?: CallParams<ProposalArgs["obj"]["op_up()void"] | ProposalArgs["tuple"]["op_up()void"]> & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            transactions: Transaction[];
            methodCalls: Map<number, import("algosdk").ABIMethod>;
            signers: Map<number, TransactionSigner>;
        }>;
    };
    /**
     * Send calls to the current app
     */
    readonly send: {
        /**
         * Gets available delete methods
         */
        delete: {
            /**
             * Deletes an existing instance of the Proposal smart contract using the `delete()void` ABI method.
             *
             * Delete the proposal.
             *
             * @param params The params for the smart contract call
             * @returns The delete result
             */
            delete: (params?: CallParams<ProposalArgs["obj"]["delete()void"] | ProposalArgs["tuple"]["delete()void"]> & SendParams) => Promise<{
                return: (undefined | ProposalReturns["delete()void"]);
                returns?: ABIReturn[] | undefined | undefined;
                groupId: string;
                txIds: string[];
                confirmations: modelsv2.PendingTransactionResponse[];
                transactions: Transaction[];
                confirmation: modelsv2.PendingTransactionResponse;
                transaction: Transaction;
            }>;
        };
        /**
         * Makes a clear_state call to an existing instance of the Proposal smart contract.
         *
         * @param params The params for the bare (raw) call
         * @returns The clearState result
         */
        clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => Promise<{
            groupId: string;
            txIds: string[];
            returns?: ABIReturn[] | undefined;
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
            return?: ABIReturn | undefined;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `submit(pay,string,uint64,uint64,uint8)void` ABI method.
         *
         * Submit the first draft of the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        submit: (params: CallParams<ProposalArgs["obj"]["submit(pay,string,uint64,uint64,uint8)void"] | ProposalArgs["tuple"]["submit(pay,string,uint64,uint64,uint8)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["submit(pay,string,uint64,uint64,uint8)void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `upload_metadata(byte[],bool)void` ABI method.
         *
         * Upload the proposal metadata.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        uploadMetadata: (params: CallParams<ProposalArgs["obj"]["upload_metadata(byte[],bool)void"] | ProposalArgs["tuple"]["upload_metadata(byte[],bool)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["upload_metadata(byte[],bool)void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `drop()string` ABI method.
         *
         * Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        drop: (params?: CallParams<ProposalArgs["obj"]["drop()string"] | ProposalArgs["tuple"]["drop()string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["drop()string"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `finalize()void` ABI method.
         *
         * Finalize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        finalize: (params?: CallParams<ProposalArgs["obj"]["finalize()void"] | ProposalArgs["tuple"]["finalize()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["finalize()void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `assign_voters((address,uint64)[])void` ABI method.
         *
         * Assign multiple voters to the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        assignVoters: (params: CallParams<ProposalArgs["obj"]["assign_voters((address,uint64)[])void"] | ProposalArgs["tuple"]["assign_voters((address,uint64)[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["assign_voters((address,uint64)[])void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `vote(address,uint64,uint64)string` ABI method.
         *
         * Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        vote: (params: CallParams<ProposalArgs["obj"]["vote(address,uint64,uint64)string"] | ProposalArgs["tuple"]["vote(address,uint64,uint64)string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["vote(address,uint64,uint64)string"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `scrutiny()void` ABI method.
         *
         * Scrutinize the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        scrutiny: (params?: CallParams<ProposalArgs["obj"]["scrutiny()void"] | ProposalArgs["tuple"]["scrutiny()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["scrutiny()void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `review(bool)void` ABI method.
         *
         * Review the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        review: (params: CallParams<ProposalArgs["obj"]["review(bool)void"] | ProposalArgs["tuple"]["review(bool)void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["review(bool)void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `fund()string` ABI method.
         *
         * Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        fund: (params?: CallParams<ProposalArgs["obj"]["fund()string"] | ProposalArgs["tuple"]["fund()string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["fund()string"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `unassign_voters(address[])void` ABI method.
         *
         * Unassign voters from the proposal.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        unassignVoters: (params: CallParams<ProposalArgs["obj"]["unassign_voters(address[])void"] | ProposalArgs["tuple"]["unassign_voters(address[])void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["unassign_voters(address[])void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `decommission()string` ABI method.
         *
         * Decommission the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        decommission: (params?: CallParams<ProposalArgs["obj"]["decommission()string"] | ProposalArgs["tuple"]["decommission()string"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["decommission()string"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
         *
         * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
         *
         * Get the proposal state.
         *
         * @param params The params for the smart contract call
         * @returns The call result: The proposal state
         */
        getState: (params?: CallParams<ProposalArgs["obj"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"] | ProposalArgs["tuple"]["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
        /**
         * Makes a call to the Proposal smart contract using the `op_up()void` ABI method.
         *
         * @param params The params for the smart contract call
         * @returns The call result
         */
        opUp: (params?: CallParams<ProposalArgs["obj"]["op_up()void"] | ProposalArgs["tuple"]["op_up()void"]> & SendParams & {
            onComplete?: OnApplicationComplete.NoOpOC;
        }) => Promise<{
            return: (undefined | ProposalReturns["op_up()void"]);
            returns?: ABIReturn[] | undefined | undefined;
            groupId: string;
            txIds: string[];
            confirmations: modelsv2.PendingTransactionResponse[];
            transactions: Transaction[];
            confirmation: modelsv2.PendingTransactionResponse;
            transaction: Transaction;
        }>;
    };
    /**
     * Clone this app client with different params
     *
     * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
     * @returns A new app client with the altered params
     */
    clone(params: CloneAppClientParams): ProposalClient;
    /**
     * Makes a readonly (simulated) call to the Proposal smart contract using the `get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)` ABI method.
     *
     * This method is a readonly method; calling it with onComplete of NoOp will result in a simulated transaction rather than a real transaction.
     *
     * Get the proposal state.
     *
     * @param params The params for the smart contract call
     * @returns The call result: The proposal state
     */
    getState(params?: CallParams<ProposalArgs['obj']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'] | ProposalArgs['tuple']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)']>): Promise<ProposalTypedGlobalState>;
    /**
     * Methods to access state for the current Proposal app
     */
    state: {
        /**
         * Methods to access global state for the current Proposal app
         */
        global: {
            /**
             * Get all current keyed values from global state
             */
            getAll: () => Promise<Partial<Expand<GlobalKeysState>>>;
            /**
             * Get the current value of the approvals key in global state
             */
            approvals: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the assigned_votes key in global state
             */
            assignedVotes: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the committee_id key in global state
             */
            committeeId: () => Promise<BinaryState>;
            /**
             * Get the current value of the committee_members key in global state
             */
            committeeMembers: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the committee_votes key in global state
             */
            committeeVotes: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the decommissioned key in global state
             */
            decommissioned: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the finalization_ts key in global state
             */
            finalizationTs: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the focus key in global state
             */
            focus: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the funding_category key in global state
             */
            fundingCategory: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the funding_type key in global state
             */
            fundingType: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the locked_amount key in global state
             */
            lockedAmount: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the nulls key in global state
             */
            nulls: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the proposer key in global state
             */
            proposer: () => Promise<BinaryState>;
            /**
             * Get the current value of the registry_app_id key in global state
             */
            registryAppId: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the rejections key in global state
             */
            rejections: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the requested_amount key in global state
             */
            requestedAmount: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the status key in global state
             */
            status: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the submission_ts key in global state
             */
            submissionTs: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the title key in global state
             */
            title: () => Promise<BinaryState>;
            /**
             * Get the current value of the vote_open_ts key in global state
             */
            voteOpenTs: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the voted_members key in global state
             */
            votedMembers: () => Promise<bigint | undefined>;
            /**
             * Get the current value of the voters_count key in global state
             */
            votersCount: () => Promise<bigint | undefined>;
        };
    };
    newGroup(): ProposalComposer;
}
export type ProposalComposer<TReturns extends [...any[]] = []> = {
    /**
     * Calls the submit(pay,string,uint64,uint64,uint8)void ABI method.
     *
     * Submit the first draft of the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    submit(params?: CallParams<ProposalArgs['obj']['submit(pay,string,uint64,uint64,uint8)void'] | ProposalArgs['tuple']['submit(pay,string,uint64,uint64,uint8)void']>): ProposalComposer<[...TReturns, ProposalReturns['submit(pay,string,uint64,uint64,uint8)void'] | undefined]>;
    /**
     * Calls the upload_metadata(byte[],bool)void ABI method.
     *
     * Upload the proposal metadata.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    uploadMetadata(params?: CallParams<ProposalArgs['obj']['upload_metadata(byte[],bool)void'] | ProposalArgs['tuple']['upload_metadata(byte[],bool)void']>): ProposalComposer<[...TReturns, ProposalReturns['upload_metadata(byte[],bool)void'] | undefined]>;
    /**
     * Calls the drop()string ABI method.
     *
     * Drop the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    drop(params?: CallParams<ProposalArgs['obj']['drop()string'] | ProposalArgs['tuple']['drop()string']>): ProposalComposer<[...TReturns, ProposalReturns['drop()string'] | undefined]>;
    /**
     * Calls the finalize()void ABI method.
     *
     * Finalize the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    finalize(params?: CallParams<ProposalArgs['obj']['finalize()void'] | ProposalArgs['tuple']['finalize()void']>): ProposalComposer<[...TReturns, ProposalReturns['finalize()void'] | undefined]>;
    /**
     * Calls the assign_voters((address,uint64)[])void ABI method.
     *
     * Assign multiple voters to the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    assignVoters(params?: CallParams<ProposalArgs['obj']['assign_voters((address,uint64)[])void'] | ProposalArgs['tuple']['assign_voters((address,uint64)[])void']>): ProposalComposer<[...TReturns, ProposalReturns['assign_voters((address,uint64)[])void'] | undefined]>;
    /**
     * Calls the vote(address,uint64,uint64)string ABI method.
     *
     * Vote on the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    vote(params?: CallParams<ProposalArgs['obj']['vote(address,uint64,uint64)string'] | ProposalArgs['tuple']['vote(address,uint64,uint64)string']>): ProposalComposer<[...TReturns, ProposalReturns['vote(address,uint64,uint64)string'] | undefined]>;
    /**
     * Calls the scrutiny()void ABI method.
     *
     * Scrutinize the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    scrutiny(params?: CallParams<ProposalArgs['obj']['scrutiny()void'] | ProposalArgs['tuple']['scrutiny()void']>): ProposalComposer<[...TReturns, ProposalReturns['scrutiny()void'] | undefined]>;
    /**
     * Calls the review(bool)void ABI method.
     *
     * Review the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    review(params?: CallParams<ProposalArgs['obj']['review(bool)void'] | ProposalArgs['tuple']['review(bool)void']>): ProposalComposer<[...TReturns, ProposalReturns['review(bool)void'] | undefined]>;
    /**
     * Calls the fund()string ABI method.
     *
     * Fund the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    fund(params?: CallParams<ProposalArgs['obj']['fund()string'] | ProposalArgs['tuple']['fund()string']>): ProposalComposer<[...TReturns, ProposalReturns['fund()string'] | undefined]>;
    /**
     * Calls the unassign_voters(address[])void ABI method.
     *
     * Unassign voters from the proposal.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    unassignVoters(params?: CallParams<ProposalArgs['obj']['unassign_voters(address[])void'] | ProposalArgs['tuple']['unassign_voters(address[])void']>): ProposalComposer<[...TReturns, ProposalReturns['unassign_voters(address[])void'] | undefined]>;
    /**
     * Calls the decommission()string ABI method.
     *
     * Decommission the proposal. MUST BE CALLED BY THE REGISTRY CONTRACT.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    decommission(params?: CallParams<ProposalArgs['obj']['decommission()string'] | ProposalArgs['tuple']['decommission()string']>): ProposalComposer<[...TReturns, ProposalReturns['decommission()string'] | undefined]>;
    /**
     * Calls the get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64) ABI method.
     *
     * Get the proposal state.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    getState(params?: CallParams<ProposalArgs['obj']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'] | ProposalArgs['tuple']['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)']>): ProposalComposer<[...TReturns, ProposalReturns['get_state()(address,uint64,string,uint64,uint64,uint64,uint64,bool,uint64,uint8,uint64,uint64,uint64,byte[32],uint64,uint64,uint64,uint64,uint64,uint64)'] | undefined]>;
    /**
     * Calls the op_up()void ABI method.
     *
     * @param args The arguments for the contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    opUp(params?: CallParams<ProposalArgs['obj']['op_up()void'] | ProposalArgs['tuple']['op_up()void']>): ProposalComposer<[...TReturns, ProposalReturns['op_up()void'] | undefined]>;
    /**
     * Gets available delete methods
     */
    readonly delete: {
        /**
         * Deletes an existing instance of the Proposal smart contract using the delete()void ABI method.
         *
         * @param args The arguments for the smart contract call
         * @param params Any additional parameters for the call
         * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
         */
        delete(params?: CallParams<ProposalArgs['obj']['delete()void'] | ProposalArgs['tuple']['delete()void']>): ProposalComposer<[...TReturns, ProposalReturns['delete()void'] | undefined]>;
    };
    /**
     * Makes a clear_state call to an existing instance of the Proposal smart contract.
     *
     * @param args The arguments for the bare call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    clearState(params?: AppClientBareCallParams): ProposalComposer<[...TReturns, undefined]>;
    /**
     * Adds a transaction to the composer
     *
     * @param txn A transaction to add to the transaction group
     * @param signer The optional signer to use when signing this transaction.
     */
    addTransaction(txn: Transaction, signer?: TransactionSigner): ProposalComposer<TReturns>;
    /**
     * Returns the underlying AtomicTransactionComposer instance
     */
    composer(): Promise<TransactionComposer>;
    /**
     * Simulates the transaction group and returns the result
     */
    simulate(): Promise<ProposalComposerResults<TReturns> & {
        simulateResponse: SimulateResponse;
    }>;
    simulate(options: SkipSignaturesSimulateOptions): Promise<ProposalComposerResults<TReturns> & {
        simulateResponse: SimulateResponse;
    }>;
    simulate(options: RawSimulateOptions): Promise<ProposalComposerResults<TReturns> & {
        simulateResponse: SimulateResponse;
    }>;
    /**
     * Sends the transaction group to the network and returns the results
     */
    send(params?: SendParams): Promise<ProposalComposerResults<TReturns>>;
};
export type ProposalComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
    returns: TReturns;
}>;
